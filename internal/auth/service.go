// Package auth provides user authentication services supporting multiple identity providers.
package auth

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/allthepins/auth-service/internal/database"
	"github.com/allthepins/auth-service/internal/platform/jwt"
	"github.com/allthepins/auth-service/internal/platform/token"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// Common errors returned by the authentication service.
var (
	ErrUserNotFound       = errors.New("user not found")
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrUserExists         = errors.New("user already exists")
	ErrInvalidProvider    = errors.New("invalid provider")
	ErrInvalidInput       = errors.New("invalid input")
	ErrInvalidToken       = errors.New("invalid or expired token")
)

// TxBeginner defines an interface for starting a database transaction.
type TxBeginner interface {
	Begin(ctx context.Context) (pgx.Tx, error)
}

// Querier extends the Querier interface generated by sqlc with transaction support.
// sqlc generates database.Querier but doesn't include WithTx in the interface,
// so it's extended here.
// https://github.com/sqlc-dev/sqlc/issues/383
type Querier interface {
	database.Querier
	WithTx(tx pgx.Tx) database.Querier
}

// Service provides authentication and user management functionality.
type Service struct {
	conn               TxBeginner
	querier            Querier
	jwt                jwt.Auth
	tokenManager       token.Manager
	logger             *slog.Logger
	providers          map[string]Provider
	refreshTokenExpiry time.Duration
}

// Config holds the configuration for the auth service
type Config struct {
	Conn               TxBeginner
	Querier            Querier
	JWT                jwt.Auth
	TokenManager       token.Manager
	Logger             *slog.Logger
	RefreshTokenExpiry time.Duration
}

// Validate checks that all required fields in the Config are set.
func (c Config) Validate() error {
	if c.Conn == nil {
		return errors.New("database connection is required")
	}
	if c.Querier == nil {
		return errors.New("querier is required")
	}
	if c.JWT == nil {
		return errors.New("JWT service is required")
	}
	if c.TokenManager == nil {
		return errors.New("token manager is required")
	}
	if c.Logger == nil {
		return errors.New("logger is required")
	}
	if c.RefreshTokenExpiry == 0 {
		return errors.New("refresh token expiry is required")
	}
	return nil
}

// NewService creates a new authentication service with the given configuration.
func NewService(c Config) (*Service, error) {
	if err := c.Validate(); err != nil {
		return nil, err
	}

	s := &Service{
		conn:               c.Conn,
		querier:            c.Querier,
		jwt:                c.JWT,
		tokenManager:       c.TokenManager,
		logger:             c.Logger,
		providers:          make(map[string]Provider),
		refreshTokenExpiry: c.RefreshTokenExpiry,
	}

	s.registerProvider(NewEmailPasswordProvider())
	return s, nil
}

// registerProvider registers a new auth provider.
func (s *Service) registerProvider(p Provider) {
	s.providers[p.Name()] = p
}

// RegisterRequest contains the info needed to register a new user.
type RegisterRequest struct {
	Provider    string         `json:"provider"`
	Credentials map[string]any `json:"credentials"`
}

// LoginRequest contains the info needed to authenticate a user.
type LoginRequest struct {
	Provider    string         `json:"provider"`
	Credentials map[string]any `json:"credentials"`
}

// User represents a user's info.
type User struct {
	ID        string    `json:"id"`
	Roles     []string  `json:"roles"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// AuthResponse contains the auth response with tokens and user info.
type AuthResponse struct {
	AccessToken  string `json:"accessToken"`
	RefreshToken string `json:"refreshToken"`
	User         User   `json:"user"`
}

// Register creates a new user account with the specified provider and credentials.
func (s *Service) Register(ctx context.Context, req RegisterRequest) (*AuthResponse, error) {
	provider, ok := s.providers[req.Provider]
	if !ok {
		s.logger.Error("invalid provider", "provider", req.Provider)
		return nil, ErrInvalidProvider
	}

	if err := provider.ValidateCredentials(req.Credentials); err != nil {
		s.logger.Error("credential validation failed", "error", err, "provider", req.Provider)
		return nil, fmt.Errorf("%w: %s", ErrInvalidInput, err.Error())
	}

	identifier, err := provider.GetIdentifier(req.Credentials)
	if err != nil {
		s.logger.Error("failed to get identifier", "error", err, "provider", req.Provider)
		return nil, err
	}

	_, err = s.querier.GetIdentityByProvider(ctx, database.GetIdentityByProviderParams{
		Provider:   req.Provider,
		ProviderID: identifier,
	})
	if err == nil {
		return nil, ErrUserExists
	}
	if err != pgx.ErrNoRows {
		s.logger.Error("database error checking identity", "error", err)
		return nil, err
	}

	preparedCreds, err := provider.PrepareCredentials(req.Credentials)
	if err != nil {
		s.logger.Error("failed to prepare credentials", "error", err)
		return nil, err
	}

	var user database.AuthUser
	err = s.withTx(ctx, func(qtx database.Querier) error {
		userID := uuid.New()

		// Always assign default "user" role
		// TODO Create admin endpoints letter for role management
		roles := []string{"user"}

		user, err = qtx.CreateUser(ctx, database.CreateUserParams{
			ID:    userID,
			Roles: roles,
		})
		if err != nil {
			return fmt.Errorf("failed to create user: %w", err)
		}

		_, err = qtx.CreateIdentity(ctx, database.CreateIdentityParams{
			ID:          uuid.New(),
			UserID:      user.ID,
			Provider:    req.Provider,
			ProviderID:  identifier,
			Credentials: preparedCreds,
		})
		if err != nil {
			// Handle concurrent registration race condition.
			// Multiple requests may pass the pre-check but hit unique constraint in DB
			if isPgUniqueViolation(err) {
				return ErrUserExists
			}
			return fmt.Errorf("failed to create identity: %w", err)
		}

		return nil
	})

	if err != nil {
		// Check if it's the user already exists error from transaction
		if errors.Is(err, ErrUserExists) {
			return nil, ErrUserExists
		}
		s.logger.Error("failed to register user", "error", err, "provider", req.Provider)
		return nil, err
	}

	accessToken, err := s.jwt.GenerateToken(user.ID.String())
	if err != nil {
		s.logger.Error("failed to generate access token", "error", err)
		return nil, err
	}

	s.logger.Info("user registered successfully",
		"user_id", user.ID,
		"provider", req.Provider,
		"identifier", identifier,
	)

	// TODO Look into if it's better practice to include refresh token creation in
	// the 'register' transaction, as refresh token generation failure is a data integrity issue.
	refreshToken, err := s.createRefreshToken(ctx, user.ID)
	if err != nil {
		s.logger.Error("failed to create refresh token", "error", err)
		return nil, err
	}

	return &AuthResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		User: User{
			ID:        user.ID.String(),
			Roles:     user.Roles,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		},
	}, nil
}

// Login authenticates a user with the specified provider and credentials.
func (s *Service) Login(ctx context.Context, req LoginRequest) (*AuthResponse, error) {
	provider, ok := s.providers[req.Provider]
	if !ok {
		s.logger.Error("invalid provider", "provider", req.Provider)
		return nil, ErrInvalidProvider
	}

	identifier, err := provider.GetIdentifier(req.Credentials)
	if err != nil {
		s.logger.Error("failed to get identifier", "error", err, "provider", req.Provider)
		return nil, err
	}

	identity, err := s.querier.GetIdentityByProvider(ctx, database.GetIdentityByProviderParams{
		Provider:   req.Provider,
		ProviderID: identifier,
	})
	if err == pgx.ErrNoRows {
		s.logger.Warn("login attempt for non-existent user",
			"provider", req.Provider,
			"identifier", identifier,
		)
		return nil, ErrUserNotFound
	}
	if err != nil {
		s.logger.Error("database error fetching identity", "error", err)
		return nil, err
	}

	if err := provider.VerifyCredentials(req.Credentials, identity.Credentials); err != nil {
		s.logger.Warn("invalid credentials",
			"provider", req.Provider,
			"identifier", identifier,
		)
		return nil, ErrInvalidCredentials
	}

	user, err := s.querier.GetUserByID(ctx, identity.UserID)
	if err != nil {
		s.logger.Error("failed to fetch user", "error", err, "user_id", identity.UserID)
		return nil, err
	}

	accessToken, err := s.jwt.GenerateToken(user.ID.String())
	if err != nil {
		s.logger.Error("failed to generate access token", "error", err)
		return nil, err
	}

	refreshToken, err := s.createRefreshToken(ctx, user.ID)
	if err != nil {
		s.logger.Error("failed to create refresh token", "error", err)
		return nil, err
	}

	s.logger.Info("user logged in successfully",
		"user_id", user.ID,
		"provider", req.Provider,
		"identifier", identifier,
	)

	return &AuthResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		User: User{
			ID:        user.ID.String(),
			Roles:     user.Roles,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		},
	}, nil
}

// GetUserByID retrieves a user by their ID.
func (s *Service) GetUserByID(ctx context.Context, userID string) (*database.AuthUser, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := s.querier.GetUserByID(ctx, uid)
	if err == pgx.ErrNoRows {
		return nil, ErrUserNotFound
	}
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// withTx executes a function within a db transaction.
func (s *Service) withTx(ctx context.Context, fn func(database.Querier) error) error {
	tx, err := s.conn.Begin(ctx)
	if err != nil {
		return err
	}

	qtx := s.querier.WithTx(tx)
	err = fn(qtx)

	if err != nil {
		_ = tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}

// createRefreshToken generates and stores a new refresh token for the user.
func (s *Service) createRefreshToken(ctx context.Context, userID uuid.UUID) (string, error) {
	refreshToken, err := s.tokenManager.Generate()
	if err != nil {
		return "", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	tokenHash, err := s.tokenManager.Hash(refreshToken)
	if err != nil {
		return "", fmt.Errorf("failed to hash refresh token: %w", err)
	}

	expiresAt := time.Now().Add(s.refreshTokenExpiry)

	_, err = s.querier.CreateRefreshToken(ctx, database.CreateRefreshTokenParams{
		ID:        uuid.New(),
		UserID:    userID,
		TokenHash: tokenHash,
		ExpiresAt: expiresAt,
	})

	if err != nil {
		return "", fmt.Errorf("failed to store refresh token: %w", err)
	}

	return refreshToken, nil
}

// Refresh validates a given refresh token and issues new access and refresh tokens.
// The old (given) refresh token is revoked (i.e. rotated).
func (s *Service) Refresh(ctx context.Context, refreshToken string) (*AuthResponse, error) {
	tokenHash, err := s.tokenManager.Hash(refreshToken)
	if err != nil {
		s.logger.Error("failed to hash provided refresh token", "error", err)
		return nil, ErrInvalidToken
	}

	storedToken, err := s.querier.GetRefreshTokenByHash(ctx, tokenHash)
	if err == pgx.ErrNoRows {
		s.logger.Warn("refresh token not found or already revoked")
		return nil, ErrInvalidToken
	}
	if err != nil {
		s.logger.Error("database error fetching refresh token", "error", err)
		return nil, err
	}

	if time.Now().After(storedToken.ExpiresAt) {
		s.logger.Warn("refresh token has expired", "user_id", storedToken.UserID)
		return nil, ErrInvalidToken
	}

	// Revoke the old token
	if err := s.querier.RevokeRefreshToken(ctx, tokenHash); err != nil {
		s.logger.Error("failed to revoke old refresh token", "error", err)
	}

	// Fetch user
	user, err := s.querier.GetUserByID(ctx, storedToken.UserID)
	if err != nil {
		s.logger.Error("failed to fetch user", "error", err, "user_id", storedToken.UserID)
		return nil, err
	}

	// Generate new tokens
	accessToken, err := s.jwt.GenerateToken(user.ID.String())
	if err != nil {
		s.logger.Error("failed to generate new access token", "error", err)
		return nil, err
	}

	newRefreshToken, err := s.createRefreshToken(ctx, user.ID)
	if err != nil {
		s.logger.Error("failed to create new refresh token", "error", err)
		return nil, err
	}

	s.logger.Info("tokens refreshed successfully", "user_id", user.ID)

	return &AuthResponse{
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
		User: User{
			ID:        user.ID.String(),
			Roles:     user.Roles,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		},
	}, nil
}

// Logout revokes a refresh token.
func (s *Service) Logout(ctx context.Context, refreshToken string) error {
	tokenHash, err := s.tokenManager.Hash(refreshToken)
	if err != nil {
		s.logger.Error("failed to hash refresh token for logout", "error", err)
		return ErrInvalidToken
	}

	if err := s.querier.RevokeRefreshToken(ctx, tokenHash); err != nil {
		s.logger.Error("failed to revoke refresh token", "error", err)
		return err
	}

	s.logger.Info("user logged out successfully")
	return nil
}

// isPgUniqueViolation checks if an error is a PostgreSQL unique constraint violation.
// This is used to detect concurrent registration attempts that pass the pre-check
// but hit the database unique constraint.
func isPgUniqueViolation(err error) bool {
	if err == nil {
		return false
	}

	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		// 23505 is PostgreSQL's unique_violation error code
		return pgErr.Code == "23505"
	}
	return false
}
