// Package auth provides user authentication services supporting multiple identity providers.
package auth

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/allthepins/auth-service/internal/database"
	"github.com/allthepins/auth-service/internal/platform/jwt"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// Common errors returned by the authentication service.
var (
	ErrUserNotFound       = errors.New("user not found")
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrUserExists         = errors.New("user already exists")
	ErrInvalidProvider    = errors.New("invalid provider")
	ErrInvalidInput       = errors.New("invalid input")
)

// TxBeginner defines an interface for starting a database transaction.
type TxBeginner interface {
	Begin(ctx context.Context) (pgx.Tx, error)
}

// Querier extends the Querier interface generated by sqlc with transaction support.
// sqlc generates database.Querier but doesn't include WithTx in the interface,
// so it's extended here.
// https://github.com/sqlc-dev/sqlc/issues/383
type Querier interface {
	database.Querier
	WithTx(tx pgx.Tx) database.Querier
}

// Service provides authentication and user management functionality.
type Service struct {
	conn      TxBeginner
	querier   Querier
	jwt       jwt.Auth
	logger    *slog.Logger
	providers map[string]Provider
}

// Config holds the configuration for the auth service
type Config struct {
	Conn    TxBeginner
	Querier Querier
	JWT     jwt.Auth
	Logger  *slog.Logger
}

// Validate checks that all required fields in the Config are set.
func (c Config) Validate() error {
	if c.Conn == nil {
		return errors.New("database connection is required")
	}
	if c.Querier == nil {
		return errors.New("querier is required")
	}
	if c.JWT == nil {
		return errors.New("JWT service is required")
	}
	if c.Logger == nil {
		return errors.New("logger is required")
	}
	return nil
}

// NewService creates a new authentication service with the given configuration.
func NewService(c Config) (*Service, error) {
	if err := c.Validate(); err != nil {
		return nil, err
	}

	s := &Service{
		conn:      c.Conn,
		querier:   c.Querier,
		jwt:       c.JWT,
		logger:    c.Logger,
		providers: make(map[string]Provider),
	}

	s.registerProvider(NewEmailPasswordProvider())
	return s, nil
}

// registerProvider registers a new auth provider.
func (s *Service) registerProvider(p Provider) {
	s.providers[p.Name()] = p
}

// RegisterRequest contains the info needed to register a new user.
type RegisterRequest struct {
	Provider    string         `json:"provider"`
	Credentials map[string]any `json:"credentials"`
}

// LoginRequest contains the info needed to authenticate a user.
type LoginRequest struct {
	Provider    string         `json:"provider"`
	Credentials map[string]any `json:"credentials"`
}

// User represents a user's info.
type User struct {
	ID        string    `json:"id"`
	Roles     []string  `json:"roles"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// AuthResponse contains the auth response with tokens and user info.
type AuthResponse struct {
	AccessToken string `json:"accessToken"`
	User        User   `json:"user"`
}

// Register creates a new user account with the specified provider and credentials.
func (s *Service) Register(ctx context.Context, req RegisterRequest) (*AuthResponse, error) {
	provider, ok := s.providers[req.Provider]
	if !ok {
		s.logger.Error("invalid provider", "provider", req.Provider)
		return nil, ErrInvalidProvider
	}

	if err := provider.ValidateCredentials(req.Credentials); err != nil {
		s.logger.Error("credential validation failed", "error", err, "provider", req.Provider)
		return nil, fmt.Errorf("%w: %s", ErrInvalidInput, err.Error())
	}

	identifier, err := provider.GetIdentifier(req.Credentials)
	if err != nil {
		s.logger.Error("failed to get identifier", "error", err, "provider", req.Provider)
		return nil, err
	}

	_, err = s.querier.GetIdentityByProvider(ctx, database.GetIdentityByProviderParams{
		Provider:   req.Provider,
		ProviderID: identifier,
	})
	if err == nil {
		return nil, ErrUserExists
	}
	if err != pgx.ErrNoRows {
		s.logger.Error("database error checking identity", "error", err)
		return nil, err
	}

	preparedCreds, err := provider.PrepareCredentials(req.Credentials)
	if err != nil {
		s.logger.Error("failed to prepare credentials", "error", err)
		return nil, err
	}

	var user database.AuthUser
	err = s.withTx(ctx, func(qtx database.Querier) error {
		userID := uuid.New()

		// Always assign default "user" role
		// TODO Create admin endpoints letter for role management
		roles := []string{"user"}

		user, err = qtx.CreateUser(ctx, database.CreateUserParams{
			ID:    userID,
			Roles: roles,
		})
		if err != nil {
			return fmt.Errorf("failed to create user: %w", err)
		}

		_, err = qtx.CreateIdentity(ctx, database.CreateIdentityParams{
			ID:          uuid.New(),
			UserID:      user.ID,
			Provider:    req.Provider,
			ProviderID:  identifier,
			Credentials: preparedCreds,
		})
		if err != nil {
			return fmt.Errorf("failed to create identity: %w", err)
		}

		return nil
	})

	if err != nil {
		s.logger.Error("failed to register user", "error", err, "provider", req.Provider)
		return nil, err
	}

	accessToken, err := s.jwt.GenerateToken(user.ID.String())
	if err != nil {
		s.logger.Error("failed to generate access token", "error", err)
		return nil, err
	}

	s.logger.Info("user registered successfully",
		"user_id", user.ID,
		"provider", req.Provider,
		"identifier", identifier,
	)

	return &AuthResponse{
		AccessToken: accessToken,
		User: User{
			ID:        user.ID.String(),
			Roles:     user.Roles,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		},
	}, nil
}

// Login authenticates a user with the specified provider and credentials.
func (s *Service) Login(ctx context.Context, req LoginRequest) (*AuthResponse, error) {
	provider, ok := s.providers[req.Provider]
	if !ok {
		s.logger.Error("invalid provider", "provider", req.Provider)
		return nil, ErrInvalidProvider
	}

	identifier, err := provider.GetIdentifier(req.Credentials)
	if err != nil {
		s.logger.Error("failed to get identifier", "error", err, "provider", req.Provider)
		return nil, err
	}

	identity, err := s.querier.GetIdentityByProvider(ctx, database.GetIdentityByProviderParams{
		Provider:   req.Provider,
		ProviderID: identifier,
	})
	if err == pgx.ErrNoRows {
		s.logger.Warn("login attempt for non-existent user",
			"provider", req.Provider,
			"identifier", identifier,
		)
		return nil, ErrUserNotFound
	}
	if err != nil {
		s.logger.Error("database error fetching identity", "error", err)
		return nil, err
	}

	if err := provider.VerifyCredentials(req.Credentials, identity.Credentials); err != nil {
		s.logger.Warn("invalid credentials",
			"provider", req.Provider,
			"identifier", identifier,
		)
		return nil, ErrInvalidCredentials
	}

	user, err := s.querier.GetUserByID(ctx, identity.UserID)
	if err != nil {
		s.logger.Error("failed to fetch user", "error", err, "user_id", identity.UserID)
		return nil, err
	}

	accessToken, err := s.jwt.GenerateToken(user.ID.String())
	if err != nil {
		s.logger.Error("failed to generate access token", "error", err)
		return nil, err
	}

	s.logger.Info("user logged in successfully",
		"user_id", user.ID,
		"provider", req.Provider,
		"identifier", identifier,
	)

	return &AuthResponse{
		AccessToken: accessToken,
		User: User{
			ID:        user.ID.String(),
			Roles:     user.Roles,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		},
	}, nil
}

// GetUserByID retrieves a user by their ID.
func (s *Service) GetUserByID(ctx context.Context, userID string) (*database.AuthUser, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := s.querier.GetUserByID(ctx, uid)
	if err == pgx.ErrNoRows {
		return nil, ErrUserNotFound
	}
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// withTx executes a function within a db transaction.
func (s *Service) withTx(ctx context.Context, fn func(database.Querier) error) error {
	tx, err := s.conn.Begin(ctx)
	if err != nil {
		return err
	}

	qtx := s.querier.WithTx(tx)
	err = fn(qtx)

	if err != nil {
		_ = tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}
